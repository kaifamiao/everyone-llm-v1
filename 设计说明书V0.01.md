# Everyone-LLM设计说明书 V0.0.1

版本信息

​	•	文档版本：1.0

​	•	日期：2025-11-25

​	•	作者：Rory Lin

## 1. 系统概述



**Everyone-LLM 是基于 NextChat 开源项目改造的多用户算力平台，采用前后端分离架构：前端使用 Vue3 + Nuxt4，后端使用 Python3.11 + FastAPI，主要功能包括：**

- **多用户注册、登录与会话管理**：支持 JWT + Refresh Token 认证

- **聊天对话功能**：支持 7 种对话模式（AI、文档、知识库、数据库、Web、图片、MCP）

- **AI 模型选择**：支持多种模型（GPT-4o、Claude 等）

- **多模式交互**：文档上传、知识库检索、数据库查询、Web 搜索、图片分析、MCP 协议支持

- **SSE 流式响应**：实时流式对话体验

- **Markdown 格式展示**：消息内容支持 Markdown 渲染和美化

- **历史记录管理**：支持保存、删除、搜索、导出（JSON/Markdown）

- **积分系统**：初始积分 100,000 分，Token 消耗统计和扣除

- **移动端与 PC 端适配**：响应式设计，移动端侧滑菜单

- **存储策略**：前端状态使用 Pinia 管理，对话记录存储在后端 PostgreSQL

- **对话保存与连续对话**：支持历史上下文加载和多轮对话，数据存储在后端





## 2. 技术架构

**架构模式**：前后端分离架构

- **前端**：Vue3 + Nuxt4
  - 独立部署，通过 RESTful API 与后端交互
  - 负责用户界面展示和交互逻辑

- **后端**：Python3.11 + FastAPI
  - 独立部署，提供 RESTful API 和 SSE 流式接口
  - 负责业务逻辑处理、数据存储和AI接口调用

- **图标库**：Lucide Vue Next（`npm install lucide-vue-next`）
  - 整体前端图标统一使用 Lucide 图标库

- **状态管理**：Pinia
  - 前端各种选择状态（历史记录选择、模型选择、对话方式选择、主题等）使用 Pinia 管理

- **数据库**：PostgreSQL
  - 存储用户数据、对话记录、消息内容等所有数据
  - 支持多设备同步和长期保存

- **认证**：JWT + Refresh Token

- **存储策略**：

  - **前端 Pinia**：存储用户选择状态（历史记录选择、模型选择、对话方式选择、主题等）

  - **后端 PostgreSQL**：存储所有对话记录和消息数据

    - 对话元信息：对话标题、模型、模式、时间戳（cp_conversation 表）

    - 消息记录：每条消息内容、角色（user/assistant）、时间戳、Token 统计（cp_message 表）

    - 用户数据：用户信息、会话管理（cp_user、cp_user_session 等表）

    - 支持多设备同步和长期保存





## 3. 前端页面布局



**3.1 主界面布局**

- 两栏布局：

- **左侧 Sidebar**：

  - **Logo 区域**：
    - Logo 地址：`https://cdn.sa.net/2025/04/12/57tpedf6qZ98PRz.png`
    - 样式：宽度 100%，高度 50px
    - 要求：仅显示图片，不显示文字

  - **新建对话按钮**：点击创建新对话会话

  - **搜索区域**：支持搜索历史对话记录

  - **历史对话列表**：
    - 显示所有历史对话，可滚动
    - 每条记录关联对话方式图标
    - 支持选中状态高亮显示
    - 支持删除操作

  - **积分显示**：显示当前用户积分（初始值：100000 分）

  - **设置按钮**：始终固定在底部，点击右侧弹出设置面板

- **右侧 Chat Main**：

  - **对话标题区域**：
    - 左侧：显示当前对话标题（可编辑，自动生成或手动修改）
    - 右侧：导出按钮（支持导出为 JSON/Markdown 格式，使用 Lucide 图标）

  - **对话内容区域**：
    - 用户消息：头像和气泡框靠右对齐，使用 Lucide 图标作为头像（如 User 图标）
    - 助手消息：头像和气泡框靠左对齐，使用 Lucide 图标作为头像（如 Bot 图标）
    - 消息内容支持 Markdown 格式渲染和美化
    - 每条消息支持操作按钮（使用 Lucide 图标）：
      - 点赞按钮（ThumbsUp 图标）
      - 差评按钮（ThumbsDown 图标）
      - 重发按钮（RefreshCw 图标）
      - 复制按钮（Copy 图标）
    - 内容过多时出现滚动条，自动滚动至最新消息
    - 支持流式响应时的实时更新动画

  - **输入区域**（始终固定在底部）：
    - **第一行**：
      - AI 模型选择下拉框（GPT-4o、Claude 等），向上弹出选择框，附带图标
      - 对话方式选择下拉框（7 种模式），向上弹出选择框，附带图标
      - 附件按钮（根据选择的对话方式动态显示）
    - **第二行**：
      - 输入框（支持多行输入）
      - 发送按钮




**3.2 移动端适配**

- Sidebar 默认隐藏

- 左上角显示汉堡按钮，点击弹出 Sidebar

- 点击非 Sidebar 区域自动隐藏 Sidebar






## 4. 功能模块设计



**4.1 新建对话功能**

✅ **功能特性**：

1. **AI 模型选择**：
   - 支持多种模型（GPT-4o、Claude 等）
   - 下拉选择框向上弹出，附带图标
   - 选择状态保存至 Pinia

2. **对话方式选择**（7 种模式）：
   - AI 对话、文档对话、知识库对话、数据库对话、Web 对话、图片对话、MCP 对话
   - 下拉选择框向上弹出，每个选项附带对应图标
   - 选择状态保存至 Pinia

3. **附件上传**：
   - 根据对话方式动态显示附件按钮
   - 文档对话：显示文档上传按钮
   - 图片对话：显示图片上传按钮
   - 知识库对话：显示知识库选择列表
   - 数据库对话：显示数据库选择列表
   - Web 对话：显示 URL 输入框
   - MCP 对话：显示 MCP 配置界面
   - AI 对话：不显示任何附件按钮

4. **状态保存**：
   - 模型选择、对话方式、附件信息保存至 Pinia（前端状态）
   - 对话创建后通过 API 保存至后端 PostgreSQL

5. **系统提示词自动生成**：
   - 根据选择的对话方式自动生成对应的系统提示词
   - 在 API 请求时作为第一条 system 消息发送

6. **OpenAI 标准格式 API 请求**：
   - 遵循 OpenAI Chat Completions API 格式
   - 支持流式响应（`stream: true`）
   - 包含历史消息上下文

**4.1.1 对话功能**

✅ **功能特性**：

1. **SSE 流式响应**：
   - 使用 Server-Sent Events（SSE）接收流式数据
   - 实时解析 `data:` 行，提取内容增量
   - 实时更新对话界面，流畅的流式体验

2. **Markdown 格式美化**：
   - 消息内容支持 Markdown 语法渲染
   - 代码高亮、表格、列表等完整支持
   - 美观的排版展示

3. **消息操作按钮**：
   - 点赞按钮：对助手回复进行好评
   - 差评按钮：对助手回复进行差评
   - 重发按钮：重新发送当前消息
   - 复制按钮：复制消息内容到剪贴板

4. **对话记录保存**：
   - 每条消息实时通过 API 保存至后端 PostgreSQL
   - 包含角色（user/assistant）、内容、时间戳、Token 统计
   - 支持多设备同步访问

5. **历史记录连续对话**：
   - 选中历史对话后，加载完整消息记录
   - 支持继续对话，自动携带历史上下文
   - 上下文长度由设置中的历史记录条数控制

6. **导出对话**：
   - 支持导出为 JSON 格式（完整数据结构）
   - 支持导出为 Markdown 格式（可读性强）
   - 保留消息角色、时间戳等信息

7. **对话标题生成**：
   - **生成时机**：对话创建时，标题为空或设置为"新对话"
   - **自动生成**：发送第一条用户消息并收到助手回复后，根据第一条用户消息内容自动生成标题（可调用AI接口生成简短标题，或截取前N个字符）
   - **手动修改**：用户可在对话标题区域手动修改标题
   - **保存方式**：标题修改后通过 API 更新到后端数据库



**4.2 对话模式及附件显示逻辑**

| **模式** | **附件区域显示** | **说明** |
|---------|----------------|---------|
| **AI 对话** | 不显示任何附件按钮 | 默认对话模式，纯文本交互 |
| **文档对话** | 显示附件上传按钮 | 支持文档文件上传 |
| **知识库对话** | 显示知识库选择列表（知识库一、知识库二...） | 从预设知识库中选择 |
| **数据库对话** | 显示数据库选择列表（数据库一、数据库二...） | 从预设数据库中选择 |
| **Web 对话** | 显示 URL 输入框 | 可输入网址进行 Web 搜索 |
| **图片对话** | 显示图片上传按钮 | 支持图片文件上传 |
| **MCP 对话** | 显示 MCP 配置界面 | 支持 MCP 协议配置 |

**对话方式选择框要求**：
- 选择框向上弹出（Popover/Popup 向上展开）
- 每个选项附带对应图标（使用 Lucide 图标库）
- 选择后更新 Pinia 状态，保持选中状态



**4.3 设置面板**

- **触发方式**：点击 Sidebar 底部的设置按钮，右侧弹出设置对话框

- **功能模块**：

  1. **主题设置**：
     - 明暗主题切换开关
     - 主题状态保存至 Pinia

  2. **AI 参数配置**：
     - 历史记录条数（控制上下文长度）
     - 温度（Temperature）参数
     - 最大 Token 数（Max Tokens）

  3. **API 配置**：
     - API Key 输入框（支持保存）
     - API URL 输入框（默认：`https://api.kfm.plus/v1/chat/completions`）

  4. **文档上传设置**：
     - 文件大小限制配置
     - 支持的文件类型配置

  5. **Web 搜索地址配置**：
     - 自定义 Web 搜索服务地址

  6. **数据库连接参数设置**：
     - 数据库连接配置（数据库一、数据库二等）

  7. **知识库列表选择**：
     - 显示可用知识库列表
     - 支持添加/删除知识库

  8. **图片上传设置**：
     - 图片大小限制
     - 支持格式配置




**4.4 界面功能**

✅ **功能特性**：

1. **侧边栏历史记录显示**：
   - 显示所有历史对话列表
   - 支持滚动浏览
   - 显示对话标题、时间、对话方式图标

2. **图标关联对话方式**：
   - 每个对话方式使用对应的 Lucide 图标
   - 历史记录列表中显示图标，便于识别

3. **历史记录删除**：
   - 支持删除单个对话记录
   - 通过 API 从后端 PostgreSQL 中删除对话及其所有消息
   - 删除操作需要确认（可选）

4. **搜索对话记录**：
   - 搜索框支持按标题搜索
   - 实时过滤显示匹配的对话
   - 搜索结果高亮显示

5. **选中状态保存**：
   - 选中的对话在列表中高亮显示
   - 选中状态保存至 Pinia，刷新后保持
   - 加载选中对话的完整消息记录

**4.5 积分与 Token 系统**

✅ **功能特性**：

1. **积分系统**：
   - 初始积分：100,000 分（用户注册时在后端创建积分记录）
   - 积分显示在 Sidebar 中（从后端API实时获取）
   - 积分数据存储在后端 PostgreSQL 的 cp_user_credit 表
   - Pinia 仅用于临时缓存当前积分值，便于快速显示

2. **Token 统计**：
   - 统计每次对话的 Token 消耗
   - 从 API 响应的 `usage` 字段获取，或客户端计算
   - 记录每条消息的 Token 数量，保存至后端 PostgreSQL 的 cp_message 表

3. **积分扣除逻辑**：
   - **扣除时机**：在发送消息前检查积分是否充足，消息发送成功后扣除积分
   - **扣除规则**：根据对话消耗的 Token 数量扣除积分（可在设置中配置，如：1 Token = 1 积分）
   - **对话方式关联**：积分扣除记录会关联到具体的对话和对话方式（mode），便于统计和分析不同对话方式的积分消耗
   - **扣除记录**：每次积分扣除都会在 `cp_credit_deduction` 表中创建一条详细记录，包括：
     - 用户ID、对话ID、消息ID
     - 对话方式（mode）
     - Token数量、扣除金额
     - 扣除后的剩余积分
     - 扣除时间
   - **原子性保证**：积分扣除、积分记录创建与消息保存使用数据库事务，确保数据一致性
   - **实时更新**：扣除成功后，实时更新 `cp_user_credit` 表的积分总额、创建扣除记录、更新 Pinia 中的积分值和 Sidebar 显示
   - **失败处理**：如果积分不足，禁止发送消息并提示用户；如果扣除失败，回滚事务，不创建任何记录

4. **积分不足提示**：
   - 发送消息前检查：如果积分不足，禁用发送按钮并提示"积分不足，请充值"
   - 扣除失败处理：如果扣除过程中失败，提示错误并保持积分不变






## 5. 对话保存与历史管理

### 5.0 核心数据设计（三大核心需求）

**1. ✅ 历史对话完整保存**

- **对话表（cp_conversation）**：
  - 存储所有历史对话记录
  - 每个对话包含：标题、模型、对话方式（mode）、创建时间、更新时间
  - 通过 user_id 关联用户，支持按用户查询所有历史对话
  - 支持按时间排序、按标题搜索、按对话方式筛选

- **消息表（cp_message）**：
  - 存储所有历史消息记录
  - 每条消息包含：角色（user/assistant）、内容、Token数量、创建时间
  - 通过 conversation_id 关联到对话，支持查询对话的所有消息
  - 消息按时间顺序保存，支持加载完整对话历史

- **数据持久化**：
  - 所有对话和消息永久保存在 PostgreSQL 数据库中
  - 支持多设备同步访问
  - 删除对话时级联删除相关消息

**2. ✅ 对话方式完整记录**

- **对话方式存储**：
  - 在 cp_conversation 表的 mode 字段存储对话方式
  - 支持7种模式：'AI'、'DOC'、'KB'、'DB'、'WEB'、'IMG'、'MCP'
  - 创建对话时必须指定 mode
  - mode 值在整个对话生命周期中保持不变

- **对话方式关联**：
  - 历史对话列表显示时，根据 mode 显示对应图标
  - 支持按 mode 筛选不同对话方式的对话
  - 积分扣除记录中也保存 mode，便于按对话方式统计积分消耗

**3. ✅ 积分扣除完整记录（按用户和对话方式）**

- **积分扣除记录表（cp_credit_deduction）**：
  - 记录每次积分扣除的完整信息
  - **关联用户**：通过 user_id 关联到 cp_user 表
  - **关联对话**：通过 conversation_id 关联到 cp_conversation 表
  - **关联对话方式**：通过 mode 字段记录对话方式，从对话表获取并保存
  - **关联消息**：通过 message_id 关联到 cp_message 表，精确记录是哪条消息产生的扣除

- **扣除记录内容**：
  - user_id：用户ID
  - conversation_id：对话ID
  - message_id：消息ID
  - mode：对话方式（AI/DOC/KB/DB/WEB/IMG/MCP）
  - token_count：Token数量
  - deduction_amount：扣除金额
  - remaining_credits：扣除后的剩余积分
  - created_at：扣除时间

- **统计分析支持**：
  - 按用户统计：查询某个用户的所有积分扣除记录
  - 按对话方式统计：查询某种对话方式（如AI对话）的总积分消耗
  - 按对话统计：查询某个对话的总积分消耗
  - 按时间段统计：查询某个时间段的积分消耗趋势



**5.1 保存策略**

​	1.	**前端存储（Pinia）**

​	•	**Pinia**：存储用户选择状态（当前选中对话、模型、对话方式、主题等）

​	•	存储内容：
     - 当前选中的对话 ID
     - 当前选择的 AI 模型
     - 当前选择的对话方式
     - 明暗主题设置
     - 用户偏好设置（临时状态）

​	2.	**后端存储（PostgreSQL）**

​	•	**cp_conversation**：对话元信息（历史对话）
     - 对话标题、模型、模式（mode）、时间戳、对话ID、用户ID
     - 通过 user_id 关联用户，支持按用户查询所有历史对话
     - 通过 mode 字段记录对话方式（AI、文档、知识库等7种模式）
     - **历史对话查询**：支持按用户ID查询所有历史对话，按对话方式筛选，按时间排序
     - **对话方式存储**：mode 字段存储为 VARCHAR(10)，值为：'AI'、'DOC'、'KB'、'DB'、'WEB'、'IMG'、'MCP'

​	•	**cp_message**：消息记录（历史消息）
     - 每条消息的 role、content、时间戳、Token 统计、所属对话ID
     - 通过 conversation_id 关联到对话，支持查询对话的所有消息

​	•	**cp_credit_deduction**：积分扣除记录（关联用户和对话方式）
     - 记录每次积分扣除的详细信息
     - **关联用户**：通过 user_id 关联到 cp_user 表，每条记录都属于特定用户
     - **关联对话**：通过 conversation_id 关联到 cp_conversation 表，每条扣除记录属于特定对话
     - **关联对话方式**：通过 mode 字段记录对话方式（从对话表中获取），支持按对话方式统计
     - **关联消息**：通过 message_id 关联到 cp_message 表，精确记录是哪条消息产生的积分扣除
     - 包含Token数量、扣除金额、扣除后的剩余积分
     - **统计分析支持**：
       - 按用户统计总积分消耗
       - 按对话方式统计各模式的积分消耗
       - 按时间段统计积分消耗趋势
       - 按对话统计单个对话的积分消耗

​	•	所有对话记录和消息数据存储在后端 PostgreSQL 数据库中

​	•	支持多设备同步和长期保存

​	•	通过 RESTful API 进行数据的增删改查操作



**5.2 连续对话**

- 每个会话可多轮连续对话

- 系统基于 conversation_id + 历史消息生成上下文

- 支持 SSE 流式响应




**5.3 历史记录管理**

- Sidebar 显示历史对话列表，支持滚动

- 每条历史记录关联对话方式图标（使用 Lucide 图标）

- 支持功能：
  - 选中对话（高亮显示，状态保存至 Pinia）
  - 删除对话（通过 API 从后端 PostgreSQL 中删除）
  - 搜索对话（通过 API 在后端搜索，按标题或内容搜索）
  - 导出对话（支持 JSON/Markdown 格式）
    - JSON 格式：保留完整消息结构、角色、时间戳
    - Markdown 格式：可读性强的对话记录格式

- 连续对话：选中历史对话后，通过 API 从后端加载该对话的完整消息记录，支持继续对话




**5.4 数据库表结构（PostgreSQL）**



```sql
CREATE TABLE cp_conversation (

  id BIGINT PRIMARY KEY AUTO_INCREMENT,

  user_id BIGINT NOT NULL,

  title VARCHAR(255),

  model VARCHAR(50),

  mode ENUM('AI','DOC','KB','DB','WEB','IMG','MCP'),

  status ENUM('active','archived') DEFAULT 'active',

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY(user_id) REFERENCES cp_user(id)

);


```



```sql
CREATE TABLE cp_message (

  id BIGINT PRIMARY KEY AUTO_INCREMENT,

  conversation_id BIGINT NOT NULL,

  role ENUM('user','assistant'),

  content TEXT,

  token_count INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY(conversation_id) REFERENCES cp_conversation(id)

);


```



**5.5 数据同步策略**

- 对话记录存储在后端 PostgreSQL 数据库中

- 前端通过 RESTful API 与后端进行数据交互

- 本地状态（Pinia）保存用户选择状态，不存储对话数据

- 支持多设备同步：所有设备访问同一后端数据库

- 数据加载流程：
  1. 用户登录后，通过 API 加载历史对话列表
  2. 选中对话后，通过 API 加载该对话的消息记录
  3. 发送新消息时，实时通过 API 保存至后端
  4. 删除对话时，通过 API 从后端删除






## 6. 多用户认证与会话管理



**6.1 数据库设计**



cp_user, cp_user_profile, cp_role, cp_permission, cp_user_role, cp_role_permission,

cp_user_session, cp_login_log, cp_verify_code



**6.2 会话管理**

- JWT + Refresh Token

- 多设备登录支持

- 支持列出会话、撤销单个/全部会话




**6.3 API 设计**

- 注册 /api/v1/auth/register

- 登录 /api/v1/auth/login

- 刷新 Token /api/v1/auth/refresh

- 登出 /api/v1/auth/logout

- 获取当前用户 /api/v1/auth/me

- 验证码 /api/v1/auth/send-code, /api/v1/auth/verify-code




## 7. 数据库完整设计



**7.1 用户基础表**



```sql
-- 用户基础表
CREATE TABLE cp_user (
  id BIGSERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(30) UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active','disabled','locked')),
  last_login_ip VARCHAR(45),
  last_login_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_user_username ON cp_user(username);
CREATE INDEX idx_user_email ON cp_user(email);

-- 用户资料表
CREATE TABLE cp_user_profile (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL UNIQUE,
  nickname VARCHAR(100),
  avatar_url VARCHAR(500),
  bio TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE
);

-- 用户积分表
CREATE TABLE cp_user_credit (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL UNIQUE,
  credits BIGINT DEFAULT 100000 NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE
);

-- 积分扣除记录表（记录每次积分扣除的详细信息，关联用户、对话、对话方式）
CREATE TABLE cp_credit_deduction (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  conversation_id BIGINT NOT NULL,
  message_id BIGINT,
  mode VARCHAR(10) CHECK (mode IN ('AI','DOC','KB','DB','WEB','IMG','MCP')),
  token_count INT NOT NULL,
  deduction_amount BIGINT NOT NULL,
  deduction_rate DECIMAL(10,4) DEFAULT 1.0, -- 扣除率，如1 Token = 1积分时，rate=1.0
  remaining_credits BIGINT NOT NULL, -- 扣除后的剩余积分
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE,
  FOREIGN KEY (conversation_id) REFERENCES cp_conversation(id) ON DELETE CASCADE,
  FOREIGN KEY (message_id) REFERENCES cp_message(id) ON DELETE SET NULL
);

CREATE INDEX idx_credit_deduction_user_id ON cp_credit_deduction(user_id);
CREATE INDEX idx_credit_deduction_conversation_id ON cp_credit_deduction(conversation_id);
CREATE INDEX idx_credit_deduction_created_at ON cp_credit_deduction(created_at DESC);
CREATE INDEX idx_credit_deduction_mode ON cp_credit_deduction(mode);

```



**7.2 角色权限表**

```sql
-- 角色表
CREATE TABLE cp_role (
  id BIGSERIAL PRIMARY KEY,
  role_name VARCHAR(50) UNIQUE NOT NULL,
  role_code VARCHAR(50) UNIQUE NOT NULL,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 权限表
CREATE TABLE cp_permission (
  id BIGSERIAL PRIMARY KEY,
  permission_name VARCHAR(100) UNIQUE NOT NULL,
  permission_code VARCHAR(100) UNIQUE NOT NULL,
  resource VARCHAR(100),
  action VARCHAR(50),
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户角色关联表
CREATE TABLE cp_user_role (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE,
  FOREIGN KEY (role_id) REFERENCES cp_role(id) ON DELETE CASCADE,
  UNIQUE(user_id, role_id)
);

-- 角色权限关联表
CREATE TABLE cp_role_permission (
  id BIGSERIAL PRIMARY KEY,
  role_id BIGINT NOT NULL,
  permission_id BIGINT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (role_id) REFERENCES cp_role(id) ON DELETE CASCADE,
  FOREIGN KEY (permission_id) REFERENCES cp_permission(id) ON DELETE CASCADE,
  UNIQUE(role_id, permission_id)
);

CREATE INDEX idx_user_role_user_id ON cp_user_role(user_id);
CREATE INDEX idx_user_role_role_id ON cp_user_role(role_id);
CREATE INDEX idx_role_permission_role_id ON cp_role_permission(role_id);

```




**7.3 会话表**

```sql
-- 用户会话表
CREATE TABLE cp_user_session (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  session_token VARCHAR(255) UNIQUE NOT NULL,
  refresh_token VARCHAR(255) UNIQUE NOT NULL,
  device_info VARCHAR(255),
  ip_address VARCHAR(45),
  user_agent TEXT,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE
);

CREATE INDEX idx_session_user_id ON cp_user_session(user_id);
CREATE INDEX idx_session_token ON cp_user_session(session_token);
CREATE INDEX idx_session_expires_at ON cp_user_session(expires_at);

```




**7.4 登录日志**

```sql
-- 登录日志表
CREATE TABLE cp_login_log (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT,
  username VARCHAR(50),
  login_type VARCHAR(20) CHECK (login_type IN ('username','email','phone')),
  ip_address VARCHAR(45),
  user_agent TEXT,
  status VARCHAR(20) CHECK (status IN ('success','failed','blocked')),
  failure_reason TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_login_log_user_id ON cp_login_log(user_id);
CREATE INDEX idx_login_log_created_at ON cp_login_log(created_at DESC);
CREATE INDEX idx_login_log_status ON cp_login_log(status);

```




**7.5 验证码表**

```sql
-- 验证码表
CREATE TABLE cp_verify_code (
  id BIGSERIAL PRIMARY KEY,
  receiver VARCHAR(100) NOT NULL,
  code VARCHAR(20) NOT NULL,
  code_type VARCHAR(20) CHECK (code_type IN ('register','login','reset_password','bind','unbind')),
  channel VARCHAR(20) CHECK (channel IN ('email','sms')),
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending','used','expired')),
  ip_address VARCHAR(45),
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_verify_code_receiver ON cp_verify_code(receiver);
CREATE INDEX idx_verify_code_code ON cp_verify_code(code);
CREATE INDEX idx_verify_code_expires_at ON cp_verify_code(expires_at);

```




**7.6 对话及消息表**

```sql
-- 对话表（已在5.4节定义，此处补充说明）
CREATE TABLE cp_conversation (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  title VARCHAR(255),
  model VARCHAR(50),
  mode VARCHAR(10) CHECK (mode IN ('AI','DOC','KB','DB','WEB','IMG','MCP')),
  status VARCHAR(10) DEFAULT 'active' CHECK (status IN ('active','archived')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE
);

CREATE INDEX idx_conversation_user_id ON cp_conversation(user_id);
CREATE INDEX idx_conversation_updated_at ON cp_conversation(updated_at DESC);

-- 消息表（已在5.4节定义，此处补充说明）
CREATE TABLE cp_message (
  id BIGSERIAL PRIMARY KEY,
  conversation_id BIGINT NOT NULL,
  role VARCHAR(20) CHECK (role IN ('user','assistant','system')),
  content TEXT NOT NULL,
  token_count INT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (conversation_id) REFERENCES cp_conversation(id) ON DELETE CASCADE
);

CREATE INDEX idx_message_conversation_id ON cp_message(conversation_id);
CREATE INDEX idx_message_created_at ON cp_message(created_at);

-- updated_at 字段更新触发器（PostgreSQL不支持ON UPDATE，需要触发器）
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_conversation_updated_at BEFORE UPDATE ON cp_conversation
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_updated_at BEFORE UPDATE ON cp_user
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_profile_updated_at BEFORE UPDATE ON cp_user_profile
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_credit_updated_at BEFORE UPDATE ON cp_user_credit
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 文件上传表（用于文档对话和图片对话）
CREATE TABLE cp_file (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  conversation_id BIGINT,
  file_name VARCHAR(255) NOT NULL,
  file_type VARCHAR(50),
  file_size BIGINT,
  file_path VARCHAR(500) NOT NULL,
  file_url VARCHAR(500),
  upload_type VARCHAR(20) CHECK (upload_type IN ('document','image')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE,
  FOREIGN KEY (conversation_id) REFERENCES cp_conversation(id) ON DELETE SET NULL
);

CREATE INDEX idx_file_user_id ON cp_file(user_id);
CREATE INDEX idx_file_conversation_id ON cp_file(conversation_id);
CREATE INDEX idx_file_upload_type ON cp_file(upload_type);

**7.7 积分扣除记录表**

```sql
-- 积分扣除记录表（已在7.1节定义，此处补充说明）
-- 用于记录每次积分扣除的详细信息，关联用户、对话、对话方式
CREATE TABLE cp_credit_deduction (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  conversation_id BIGINT NOT NULL,
  message_id BIGINT,
  mode VARCHAR(10) CHECK (mode IN ('AI','DOC','KB','DB','WEB','IMG','MCP')),
  token_count INT NOT NULL,
  deduction_amount BIGINT NOT NULL,
  deduction_rate DECIMAL(10,4) DEFAULT 1.0,
  remaining_credits BIGINT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES cp_user(id) ON DELETE CASCADE,
  FOREIGN KEY (conversation_id) REFERENCES cp_conversation(id) ON DELETE CASCADE,
  FOREIGN KEY (message_id) REFERENCES cp_message(id) ON DELETE SET NULL
);

CREATE INDEX idx_credit_deduction_user_id ON cp_credit_deduction(user_id);
CREATE INDEX idx_credit_deduction_conversation_id ON cp_credit_deduction(conversation_id);
CREATE INDEX idx_credit_deduction_created_at ON cp_credit_deduction(created_at DESC);
CREATE INDEX idx_credit_deduction_mode ON cp_credit_deduction(mode);

-- 复合索引，用于按用户和对话方式统计
CREATE INDEX idx_credit_deduction_user_mode ON cp_credit_deduction(user_id, mode);
```

**说明**：
- 积分扣除记录表用于详细记录每次积分扣除，支持按用户、按对话方式、按时间维度进行统计分析
- 每次扣除都会创建记录，包含扣除时的完整上下文信息（用户、对话、消息、对话方式）
- 通过 mode 字段可以统计不同对话方式的积分消耗情况
- 该表记录每次积分扣除的完整信息，便于：
  - 查询用户的积分使用历史
  - 按对话方式统计积分消耗（不同对话方式的消耗情况）
  - 按对话统计积分消耗
  - 积分使用审计和报表分析

```






## 8. 移动端与 PC 端适配

### 8.1 PC 端要求

- Sidebar 和 Chat Main 同时正常显示
- 两栏布局，左右分栏显示
- 所有功能正常访问

### 8.2 移动端要求

- **Sidebar 默认隐藏**：初始状态下不显示 Sidebar

- **汉堡按钮**：
  - 位置：左上角
  - 功能：点击后从左侧滑出 Sidebar
  - 使用 Lucide 图标（Menu 或 AlignJustify）

- **Sidebar 显示/隐藏逻辑**：
  - 点击汉堡按钮：显示 Sidebar（覆盖层或侧滑）
  - 点击非 Sidebar 区域：自动隐藏 Sidebar
  - 点击 Sidebar 内部链接或按钮：不影响显示状态

- **布局调整**：
  - 输入区域始终固定在底部
  - 对话内容区域支持纵向滚动
  - 设置面板仍从右侧弹出

- **响应式设计**：
  - 使用 CSS 媒体查询（`@media`）区分 PC 和移动端
  - 断点建议：`768px` 或 `1024px`






## 9. 安全设计（暂时不需要）

- 密码加密：bcrypt / argon2

- JWT + Refresh Token 管理会话

- 登录失败锁定 & IP 限速

- 验证码限流

- HTTPS 全程加密

- 前端 XSS 防护、CSP

- 后端审计日志与风控






## 10. API 接口规范

### 10.1 对话接口

**接口地址**：`https://api.kfm.plus/v1/chat/completions`

**请求方式**：POST

**请求头**：
```
Authorization: Bearer {API_KEY}
Content-Type: application/json
```

**请求体格式（OpenAI 标准格式）**：
```json
{
  "model": "gpt-4o",
  "messages": [
    {
      "role": "user",
      "content": "给我一首李白的诗!"
    }
  ],
  "stream": true,
  "temperature": 0.7,
  "max_tokens": 2000
}
```

**SSE 流式响应格式**：
```
data: {"id":"chatcmpl-xxx","object":"chat.completion.chunk","created":1744222798,"model":"gpt-4o-2024-08-06","system_fingerprint":"fp_xxx","choices":[{"index":0,"delta":{"role":"assistant","content":"","refusal":null},"logprobs":null,"finish_reason":null}],"usage":null}

data: {"id":"chatcmpl-xxx","object":"chat.completion.chunk","created":1744222798,"model":"gpt-4o-2024-08-06","system_fingerprint":"fp_xxx","choices":[{"index":0,"delta":{"content":"故"},"logprobs":null,"finish_reason":null}],"usage":null}

data: {"id":"chatcmpl-xxx","object":"chat.completion.chunk","created":1744222798,"model":"gpt-4o-2024-08-06","system_fingerprint":"fp_xxx","choices":[{"index":0,"delta":{"content":"乡"},"logprobs":null,"finish_reason":null}],"usage":null}

data: {"id":"chatcmpl-xxx","object":"chat.completion.chunk","created":1744222798,"model":"gpt-4o-2024-08-06","system_fingerprint":"fp_xxx","choices":[{"index":0,"delta":{},"logprobs":null,"finish_reason":"stop"}],"usage":null}

data: [DONE]
```

**前端处理逻辑**：
1. 使用 `EventSource` 或 `fetch` + `ReadableStream` 处理 SSE 流
2. 解析每个 `data:` 行，提取 `choices[0].delta.content`
3. 实时更新对话内容，支持 Markdown 渲染
4. 统计 Token 消耗（从响应中的 `usage` 字段或客户端计算）

### 10.2 系统提示词生成

- 根据选择的对话方式自动生成对应的系统提示词
- AI 对话：基础助手提示词
- 文档对话：文档分析助手提示词
- 知识库对话：知识库检索助手提示词
- 数据库对话：数据库查询助手提示词
- Web 对话：Web 搜索助手提示词
- 图片对话：图片分析助手提示词
- MCP 对话：MCP 协议助手提示词

## 11. 特殊功能实现

### 11.1 Logo 显示

- **Logo 地址**：`https://cdn.sa.net/2025/04/12/57tpedf6qZ98PRz.png`
- **样式要求**：
  - 宽度：100%
  - 高度：50px
  - 仅显示图片，不显示文字
- **位置**：Sidebar 顶部 Logo 区域

### 11.2 积分系统

- **初始积分**：100,000 分
- **显示位置**：Sidebar 中，设置按钮上方
- **积分扣除**：根据 Token 消耗实时扣除
- **状态保存**：积分状态保存至 Pinia

### 11.3 Token 统计

- **统计方式**：从 API 响应中的 `usage` 字段获取，或客户端计算
- **记录位置**：每条消息的 Token 数量通过 API 保存至后端 PostgreSQL 的 cp_message 表
- **实时更新**：对话过程中实时统计和显示，并同步保存至后端

### 11.4 对话记录导出

- **导出格式**：
  - JSON 格式：完整的数据结构，包含所有元信息
  - Markdown 格式：可读性强的对话记录格式
- **导出位置**：对话标题区域右侧的导出按钮
- **导出内容**：包含所有消息的角色、内容、时间戳等信息

### 11.5 移动端适配

- **响应式布局**：使用 CSS 媒体查询实现
- **交互优化**：
  - 移动端 Sidebar 默认隐藏
  - 汉堡菜单控制显示/隐藏
  - 点击外部区域自动关闭 Sidebar
  - 输入区域固定底部，防止键盘遮挡

## 12. 前端技术细节

### 12.1 图标库使用

- **库名**：`lucide-vue-next`
- **安装命令**：`npm install lucide-vue-next`
- **使用场景**：
  - 用户和助手头像（User、Bot 图标）
  - 对话方式图标（7 种模式对应不同图标）
  - 功能按钮图标（新建、搜索、设置、导出、菜单等）
  - 消息操作图标（点赞、差评、重发、复制）
  - 其他 UI 图标

### 12.2 状态管理（Pinia）

**Store 结构**：
- `conversationStore`：当前选中对话、历史记录列表
- `modelStore`：当前选择的 AI 模型
- `modeStore`：当前选择的对话方式
- `themeStore`：明暗主题状态
- `settingsStore`：用户设置（API Key、URL、参数等）
- `creditStore`：积分状态

### 12.3 后端 API 接口（对话相关）

**对话管理 API**：

1. **获取对话列表**：`GET /api/v1/conversations`
   - 返回当前用户的所有对话列表
   - 包含对话标题、模型、模式、创建时间等

2. **获取对话详情**：`GET /api/v1/conversations/:id`
   - 返回指定对话的完整信息
   - 包含对话元信息和消息列表

3. **创建对话**：`POST /api/v1/conversations`
   - 创建新对话
   - 请求体：`{ title?: string, model: string, mode: string }`（title可选，默认为"新对话"）
   - 返回新创建的对话信息（包含对话ID）
   - 创建成功后，前端将新对话ID保存到Pinia并设置为当前选中对话

4. **更新对话**：`PUT /api/v1/conversations/:id`
   - 更新对话标题等信息
   - 请求体：`{ title }`

5. **删除对话**：`DELETE /api/v1/conversations/:id`
   - 删除指定对话及其所有消息

6. **搜索对话**：`GET /api/v1/conversations/search?q=关键词`
   - 按标题或内容搜索对话

7. **保存消息**：`POST /api/v1/conversations/:id/messages`
   - 保存新消息到指定对话
   - 请求体：`{ role, content, tokenCount }`

8. **获取消息列表**：`GET /api/v1/conversations/:id/messages`
   - 获取指定对话的所有消息
   - 支持分页：`?page=1&limit=50`

9. **更新对话标题**：`PUT /api/v1/conversations/:id/title`
   - 更新对话标题
   - 请求体：`{ title: string }`

10. **获取用户积分**：`GET /api/v1/user/credits`
    - 获取当前用户的积分信息
    - 返回：`{ credits: number, updated_at: timestamp }`

11. **扣除积分**：`POST /api/v1/user/credits/deduct`
    - 扣除用户积分（在消息发送成功后调用）
    - 请求体：`{ conversation_id: number, message_id: number, token_count: number, mode: string }`
    - 后端逻辑：
      - 根据对话ID获取对话方式（mode）
      - 根据Token数量和配置的扣除率计算扣除金额
      - 检查用户积分是否充足
      - 使用事务：
        1. 更新 `cp_user_credit` 表的积分总额
        2. 在 `cp_credit_deduction` 表创建扣除记录（包含用户ID、对话ID、对话方式、Token数、扣除金额等）
        3. 确保原子性
    - 返回：`{ success: boolean, remaining_credits: number, deduction_id: number }`

12. **用户设置保存**：`POST /api/v1/user/settings`
    - 保存用户设置（API Key、URL、参数等）
    - 请求体：`{ apiKey?: string, apiUrl?: string, temperature?: number, maxTokens?: number, historyCount?: number }`

13. **用户设置读取**：`GET /api/v1/user/settings`
    - 获取当前用户的设置信息

**数据同步**：
- 前端通过 RESTful API 与后端 PostgreSQL 数据库交互
- 所有对话记录和消息数据存储在后端
- 支持实时同步和多设备访问

**错误处理**：
- 统一错误响应格式：`{ code: number, message: string, data?: any }`
- 常见错误码：
  - 400: 请求参数错误
  - 401: 未认证或Token过期
  - 403: 权限不足
  - 404: 资源不存在
  - 429: 积分不足
  - 500: 服务器错误

## ✅ **总结**

**设计说明书覆盖了：**

- **前端页面布局**：Sidebar、Chat Main、输入区域、设置面板的详细设计
- **对话功能**：多模式（7种）、连续对话、SSE 流式渲染、Markdown 美化、消息操作
- **历史与导出**：PostgreSQL 后端存储、导出 JSON/Markdown 格式
- **积分系统与 Token**：初始积分 100000，Token 统计和扣除
- **多用户登录注册**：JWT + Refresh Token、验证码、会话管理
- **数据库设计**：用户、角色、权限、会话、对话与消息（PostgreSQL 存储）
- **移动端与 PC 端适配**：响应式布局、汉堡菜单、侧滑交互
- **API 接口规范**：OpenAI 标准格式、SSE 流式响应处理、RESTful API
- **前端技术栈**：Vue3 + Nuxt4 + Pinia（状态管理）+ Lucide 图标
- **后端技术栈**：Python3.11 + FastAPI + PostgreSQL + JWT 认证
- **存储策略**：前端状态使用 Pinia，对话记录存储在 PostgreSQL
- **安全策略**：密码加密、Token 管理、防护措施（可选）

